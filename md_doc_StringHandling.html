<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolbox: String Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Toolbox
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">The Reactive C++ Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">String Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>The <code>strncpy()</code> function may lead to buffer overruns when used incorrectly.</p>
<p>The purpose this article is to:</p>
<ol type="1">
<li>explain why the function is so often misunderstood;</li>
<li>offer an alternative perspective to promote safe usage.</li>
</ol>
<h2>Buffer Overruns</h2>
<p>The <code>strcpy()</code> function will result in a buffer overrun if the source string is larger than the destination:</p>
<div class="fragment"><div class="line">char buf[6];</div><div class="line">strcpy(buf, &quot;Aylett&quot;);</div></div><!-- fragment --><p>The problem here is that the zero terminator will be written beyond the end of the buffer: </p><pre class="fragment">+---+---+---+---+---+---+
| A | y | l | e | t | t |\0
+---+---+---+---+---+---+ ^
  0   1   2   3   4   5   write overrun
</pre><p>Programmers often reach for <code>strncpy()</code> as a possible solution, believing it to be a "bounded" version of <code>strcpy()</code>:</p>
<div class="fragment"><div class="line">char buf[6];</div><div class="line">strncpy(buf, &quot;Aylett&quot;, sizeof(buf));</div></div><!-- fragment --><p>But there are subtle differences. In this case, the function simply stops appending characters when the destination buffer is exhausted, and it does not truncate the destination string with a zero-terminator. This may lead to a read overrun if the consumer assumes a zero-terminated (c-style) string: </p><pre class="fragment">+---+---+---+---+---+---+
| A | y | l | e | t | t |
+---+---+---+---+---+---+
  0   1   2   3   4   5
</pre><p>This often leaves programmers wondering why <code>strncpy()</code> has such a seemingly broken contract. In order to answer this question, we need to stop thinking of <code>strncpy()</code> as a bounded version of <code>strcpy()</code>, and consider the use-case it was designed for.</p>
<h2>Data Leaks</h2>
<p>One of the advantages of C and C++ is that they allow programmers to layout their data structures in contiguous regions of memory:</p>
<div class="fragment"><div class="line">struct __attribute__((packed)) Person {</div><div class="line">  char forename[64];</div><div class="line">  char surname[64];</div><div class="line">};</div><div class="line">static_assert(sizeof(Person) == 128);</div><div class="line">static_assert(std::is_pod_v&lt;Person&gt;);</div></div><!-- fragment --><p>These "packed" data structures are ideal for wire protocols and file formats. When populating such structures, however, programmers must take care to avoid security vulnerabilities:</p>
<div class="fragment"><div class="line">Person person;</div><div class="line">strcpy(person.forename, &quot;Mark&quot;);</div><div class="line">strcpy(person.surname, &quot;Aylett&quot;);</div></div><!-- fragment --><p>This is bad, because memory locations beyond the zero-terminator are leaked to the outside world: </p><pre class="fragment">+---+---+---+---+---+---+-------+---+
| M | a | r | k |\0 | ? |  ...  | ? |
+---+---+---+---+---+---+-------+---+
  0   1   2   3   4   5    ...    63
</pre><p>If these memory locations happened to contain sensitive data, then your system is now vulnerable to attack.</p>
<h2>Message Padding</h2>
<p>To avoid exposing private memory locations, we must ensure that any unused gaps in our data structures are suitably filled. What we need is a function that copies the source string to the destination, and then fills any remaining bytes in the destination buffer with a padding:</p>
<div class="fragment"><div class="line">void pstrcpy(char* dst, const char* src, size_t n) noexcept</div><div class="line">{</div><div class="line">    // Copy source to destination.</div><div class="line">    size_t i{0};</div><div class="line">    for (; i &lt; n &amp;&amp; src[i] != &#39;\0&#39;; ++i) {</div><div class="line">       dst[i] = src[i];</div><div class="line">    }</div><div class="line">    // Pad remaining bytes with space.</div><div class="line">    for (; i &lt; n; ++i) {</div><div class="line">        dst[i] = &#39; &#39;;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The API can be simplified by inferring the size of the destination buffer:</p>
<div class="fragment"><div class="line">template &lt;std::size_t SizeN&gt;</div><div class="line">inline void pstrcpy(char (&amp;dst)[SizeN], const char* src) noexcept</div><div class="line">{</div><div class="line">    // ...</div><div class="line">}</div></div><!-- fragment --><p>This function can then be called as follows:</p>
<div class="fragment"><div class="line">char buf[6];</div><div class="line">pstrcpy(buf, &quot;Mark&quot;);</div></div><!-- fragment --><p>Which will result in a "space padded" string: </p><pre class="fragment">+---+---+---+---+---+---+
| M | a | r | k |   |   |
+---+---+---+---+---+---+
  0   1   2   3   4   5
</pre><p>Note that it is technically more correct to refer to this string encoding as "space padded" rather than "space terminated", because the string will not be "space terminated" when the source string length is greater than or equal to the destination.</p>
<h2>Strncpy Contract</h2>
<p>We are now ready to tackle the notorious <code>strncpy()</code> contract. The FreeBSD man page states that:</p>
<blockquote class="doxtable">
<p><code>strncpy()</code> copies at most <code>len</code> characters from <code>src</code> into <code>dst</code>. If <code>src</code> is less than <code>len</code> characters long, the remainder of <code>dst</code> is filled with `\0’ characters. </p>
</blockquote>
<p>Notice anything familiar about this? It is precisely the function described in the previous section, except the pad character is now a zero (‘\0’) rather than a space.</p>
<p>The following idiom is often used when zero termination is required:</p>
<div class="fragment"><div class="line">char buf[6 + 1];</div><div class="line">strncpy(buf, &quot;Aylett&quot;, sizeof(buf) - 1);</div><div class="line">buf[sizeof(buf) - 1] = &#39;\0&#39;;</div></div><!-- fragment --><p>This idiom is neatly encapsulated by the following C++ template, which avoids common programming errors regarding the buffer size:</p>
<div class="fragment"><div class="line">template &lt;std::size_t SizeN&gt;</div><div class="line">inline void zstrcpy(char (&amp;dst)[SizeN], const char* src) noexcept</div><div class="line">{</div><div class="line">    strncpy(dst, src, SizeN - 1);</div><div class="line">    dst[SizeN - 1] = &#39;\0&#39;;</div><div class="line">}</div></div><!-- fragment --><h2>Read Safety</h2>
<p>Although we now have a better understanding on the <code>strncpy()</code> contract, we still need a solution for reading these zero-padded strings without overrunning the buffer. Consider the following member function:</p>
<div class="fragment"><div class="line">const char* surname() const</div><div class="line">{</div><div class="line">    return surname_;</div><div class="line">}</div></div><!-- fragment --><p>If <code>surname_</code> is a zero-padded string with no padded, then it will not be zero-terminated and the unwary user will likely overrun the buffer when reading. Assuming that we do not want a zero-terminated string, the cleanest solution is to use <code>std::string_view&lt;&gt;</code>:</p>
<div class="fragment"><div class="line">std::string_view surname() const</div><div class="line">{</div><div class="line">    return {surname_, strnlen(surname_)};</div><div class="line">}</div></div><!-- fragment --><p>Again, the key point is to think of <code>strncpy()</code> as a function that copies a c-style string into a fixed length buffer, and then zero pads any remaining bytes.</p>
<h2>Summary</h2>
<p>In summary:</p>
<ul>
<li>the <code>strncpy()</code> is a poorly named function that is often misunderstood;</li>
<li>before using <code>strncpy()</code>, decide whether you actually want a <em>zero-terminated string</em> or a <em>zero-padded fixed length string</em>;</li>
<li>If a zero-padded fixed length string is required, then use <code>strncpy()</code> to write the string and <code>std::string_view&lt;&gt;</code> to read the string;</li>
</ul>
<p>One final word of advice: don't gloss over the details. Taking time to revisit the basics will often lead to new insights and fresh perspectives. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
