<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolbox: Concurrency</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Toolbox
   &#160;<span id="projectnumber">snapshot</span>
   </div>
   <div id="projectbrief">The Reactive C++ Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Concurrency </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Concepts</h2>
<p>Concurrent execution of code is concerned with:</p>
<ul>
<li><em>Mutual Exclusion</em>: managing contention on a shared resource;</li>
<li><em>Memory Order</em>: the order in which memory operations are observed.</li>
</ul>
<p>These concerns are typically addressed using locks and fences.</p>
<h2>Mutual Exclusion</h2>
<p>Locks provide mutually exclusive access to a shared resource. In other words, access to a shared resource is serialised, so that it cannot be accessed concurrently by multiple threads. According to <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's law</a>, performance is limited by the amount of sequential code on the critical path, so mutual exclusion must be minimised.</p>
<h3>Atomics</h3>
<p>Atomic operations are indivisibility units of work that either happen entirely or not at all. When a shared resource is modified using a single, atomic operation, such as a Compare And Swap (CAS) instruction, mutual exclusion is kept minimal, which increases the potential performance gains.</p>
<h2>Memory Order</h2>
<p>Memory order is concerned with the order in which memory operations occur both from the reader's and writer's perspective. In the absence of memory ordering constraints, memory operations that occur in program order can be reordered by both the compiler and processor. The following reorderings are theoretically possible:</p>
<p><em>LoadLoad</em>: loads reordered with other loads.</p>
<p><em>StoreStore</em>: stores reordered with other stores.</p>
<p><em>LoadStore</em>: loads reordered with subsequent stores.</p>
<p><em>StoreLoad</em>: stores reordered with subsequent loads.</p>
<p>Memory order constraints prevent one or more of these reordering from happening across a memory barrier or fence. These constraints are defined by the C11 and C++11 standards using more abstract concepts: Relaxed, Consume, Acquire, Release, Acqrel and Seqcst.</p>
<p>N.B. Few compilers track the dependency chains required to implement Consume; most compilers simply promote Consume to Acquire. Consequently, no further consideration is given to Consume in this document.</p>
<p>Memory ordering semantics, as defined by the C11 and C++11 standards, are summarised below along with their implied fences:</p>
<table class="doxtable">
<tr>
<th>memory order </th><th>fence  </th></tr>
<tr>
<td>Relaxed </td><td>no-op </td></tr>
<tr>
<td>Acquire </td><td>LoadLoad+LoadStore </td></tr>
<tr>
<td>Release </td><td>StoreStore+LoadStore </td></tr>
<tr>
<td>Acqrel </td><td>LoadLoad+StoreStore+LoadStore </td></tr>
<tr>
<td>Seqcst </td><td>LoadLoad+StoreStore+LoadStore+StoreLoad </td></tr>
</table>
<p>These concepts are covered in more detail in the following sections.</p>
<h3>Atomics</h3>
<p>Standalone fences impose memory order constraints between <em>all</em> memory operations before and after the fence. A StoreLoad fence, for example, prevents any store before the fence from being reordered with any load after the fence.</p>
<p>Atomic memory operations have the added benefit of associating fences with specific memory operations, which loosens the restrictions and provides greater opportunities for optimisation.</p>
<p>In C11 and C++11, not all combinations of atomic memory operation and memory order constraint are valid. Acquire is not valid with store operations, for example, and Release is not valid with load operations.</p>
<h3>Relaxed</h3>
<p>Relaxed provides no guarantees with respect to memory order, so it should only be used where there are no data dependencies. Sequence numbers and reference counts are most commonly associated with Relaxed semantics.</p>
<h3>Acquire</h3>
<p>Acquire prevents LoadLoad and LoadStore reorderings, so that loads before the fence cannot be reordered with loads and stores after the fence. Acquire is typically associated with an atomic load before the fence:</p>
<div class="fragment"><div class="line">mov r1 [y]          ; Load.</div><div class="line">#LoadLoad+LoadStore ; Acquire.</div></div><!-- fragment --><h3>Release</h3>
<p>Release prevents StoreStore and LoadStore reorderings, so that stores after the fence cannot be reordered with loads and stores before the fence. Release is typically associated with an atomic store after the fence:</p>
<div class="fragment"><div class="line">#StoreStore+LoadStore ; Release.</div><div class="line">mov [x] 1             ; Store.</div></div><!-- fragment --><h3>Seqcst</h3>
<p>Seqcst prevents all possible reorderings including StoreLoad, which establishes a consistent order of memory operations across all threads. Consider the following example of a ReleaseStore sequence followed by a LoadAcquire:</p>
<div class="fragment"><div class="line">#StoreStore+LoadStore ; Release.</div><div class="line">mov [x] 1             ; Store.</div><div class="line">mov r1 [y]            ; Load.</div><div class="line">#LoadLoad+LoadStore   ; Acquire.</div></div><!-- fragment --><p>Notice how sequential consistency can be broken by reordering the store and load operations. The insertion of a StoreLoad fence prevents this:</p>
<div class="fragment"><div class="line">#StoreStore+LoadStore ; Release.</div><div class="line">mov [x] 1             ; Store.</div><div class="line">#StoreLoad</div><div class="line">mov r1 [y]            ; Load.</div><div class="line">#LoadLoad+LoadStore   ; Acquire.</div></div><!-- fragment --><p>The equivalent code using C++ atomics follows:</p>
<div class="fragment"><div class="line">x.store(1, memory_order_seqcst); // +StoreLoad.</div><div class="line">auto r1 = y.load(memory_order_acquire);</div></div><!-- fragment --><p>Dekker's Algorithm, described later in this document, depends on stores happening before loads, and so it is often cited as an example use-case for Seqcst.</p>
<h3>Acqrel</h3>
<p>Unlike Acquire, Release and Seqcst, which are often used with standalone fences, Acqrel is almost exclusively used with atomic Read Modify Write (RMW) operations, such add FetchAdd.</p>
<h2>Intel</h2>
<p>One or more of these reorderings may not be possible in practice on memory architectures with stronger memory models. Intel's "64 Architecture Memory Ordering" white paper, for example, specifies the first four memory ordering principles as follows:</p>
<ol type="1">
<li>loads are not reordered with other loads;</li>
<li>stores are not reordered with other stores;</li>
<li>stores are not reordered with older loads;</li>
<li>loads may be reordered with older stores to different locations but not with older stores to the same location.</li>
</ol>
<p>The first three disallow LoadLoad, StoreStore and LoadStore reordering, while the fourth allows StoreLoad reordering. It is important to recognise, however, that without fences, compilers are free to apply any of the four reorderings.</p>
<p>The following table shows instruction sequences typically used on Intel for various memory-model combinations:</p>
<table class="doxtable">
<tr>
<th></th><th>Relaxed </th><th>Acquire </th><th>Release </th><th>Acqrel </th><th>Seqcst  </th></tr>
<tr>
<td>Load </td><td>mov </td><td>mov </td><td>N/A </td><td>N/A </td><td>mov </td></tr>
<tr>
<td>Store </td><td>mov </td><td>N/A </td><td>mov </td><td>N/A </td><td>mov; mfence </td></tr>
<tr>
<td>FetchAdd </td><td>lock add </td><td>lock add </td><td>lock add </td><td>lock add </td><td>lock add </td></tr>
</table>
<p>Note that:</p>
<ul>
<li>the <code>mfence</code> instruction is required to prevent StoreLoad reordering;</li>
<li>the typical cost of an <code>mfence</code> instruction is 100 cycles;</li>
<li>the <code>lock</code> prefix is effectively a full barrier.</li>
</ul>
<p>Some Memory Architectures, such as IA64, have load and store forms that directly model Acquire and Release semantics.</p>
<h2>GCC</h2>
<h3>Fences</h3>
<p>Simple compiler fences can be expressed using an empty assembly directive:</p>
<div class="fragment"><div class="line">__asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;);</div></div><!-- fragment --><h2>Java</h2>
<h3>Fences</h3>
<p>Java's <code>Unsafe</code> class provides access to the following fences:</p>
<ul>
<li>loadFence equivalent to Acquire;</li>
<li>storeFence equivalent to Release;</li>
<li>fullFence equivalent to Seqcst.</li>
</ul>
<h3>Volatile</h3>
<p>The Java Memory Model (JMM) defines a volatile load as an Acquire operation:</p>
<div class="fragment"><div class="line">mov r1 [y]          ; Load.</div><div class="line">#LoadLoad+LoadStore ; Acquire.</div></div><!-- fragment --><p>A volatile store is a Release operation followed by a StoreLoad fence:</p>
<div class="fragment"><div class="line">#StoreStore+LoadStore ; Release.</div><div class="line">mov [x] 1             ; Store.</div><div class="line">#StoreLoad</div></div><!-- fragment --><p>The StoreLoad fence is required to establish sequential consistency, which ensures that a volatile store cannot be reordered with a volatile load that follows it in program order:</p>
<div class="fragment"><div class="line">#StoreStore+LoadStore ; Release.</div><div class="line">mov [x] 1             ; Store.</div><div class="line">#StoreLoad</div><div class="line">mov r1 [y]            ; Load.</div><div class="line">#LoadLoad+LoadStore   ; Acquire.</div></div><!-- fragment --><p>Note that the StoreLoad fence could have instead been issued before each volatile read, but this is likely to be less efficient in practice, because volatile variables are typically read more than they are written.</p>
<p>The following <code>Unsafe</code> methods provide Release semantics without the overhead of a StoreLoad fence:</p>
<ul>
<li>putOrderedObject</li>
<li>putOrderedInt</li>
<li>putOrderedLong</li>
</ul>
<h2>Dekkerâ€™s Algorithm</h2>
<p>Dekker's Algorithm is best understood by the interleavings shown below:</p>
<p><b>Uncontended Case #1</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td>y_wants == 0 </td><td></td></tr>
<tr>
<td>Acquired </td><td></td></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td></td><td>x_wants == 1 </td></tr>
</table>
<p><b>Uncontended Case #2</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td></td><td>x_wants == 0 </td></tr>
<tr>
<td></td><td>Acquired </td></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td>y_wants == 1 </td><td></td></tr>
</table>
<p><b>Contended Case #1</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td>y_wants == 1 </td><td></td></tr>
<tr>
<td></td><td>x_wants == 1 </td></tr>
</table>
<p><b>Contended Case #2</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td></td><td>x_wants == 1 </td></tr>
<tr>
<td>y_wants == 1 </td><td></td></tr>
</table>
<p><b>Contended Case #3</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td></td><td>x_wants == 1 </td></tr>
<tr>
<td>y_wants == 1 </td><td></td></tr>
</table>
<p><b>Contended Case #4</b></p>
<table class="doxtable">
<tr>
<th>thread x </th><th>thread y  </th></tr>
<tr>
<td></td><td>y_wants = 1 </td></tr>
<tr>
<td>x_wants = 1 </td><td></td></tr>
<tr>
<td>y_wants == 1 </td><td></td></tr>
<tr>
<td></td><td>x_wants == 1 </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
